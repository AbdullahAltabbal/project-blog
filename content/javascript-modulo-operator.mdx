---
title: 'Understanding the JavaScript Modulo Operator'
abstract: One of the most commonly-misunderstood operators is Modulo (%). In this tutorial, we'll unpack exactly what this little bugger does, and learn how it can help us solve practical problems.
publishedOn: '2023-06-24T12:00:00-0400'
---

When I was first learning to code, I remember finding the Modulo operator (%) _extremely_ confusing. ðŸ˜¬

If you don't understand what it's doing, the values it produces seem completely random:

```js
const what = 10 % 4; // 2
const the = 10 % 10; // 0
const heck = 4 % 10; // 4
```

In this blog post, we're going to learn how this operator works by refining our mental model for division. We'll also cover a practical, every-day use case for this curious fella.

## Rethinking division

Suppose we have the following bit of arithmetic:

```js
12 Ã· 4
```

Division can often feel pretty abstract or theoretical, but there's a practical way to think about it: we want to divide a number into equally-sized groups.

**Drag the slider to see how this operation can be visualized:**

<DivisionGroupsDemo />

`12 Ã· 4` evaluates to `3`, because each group holds exactly 3 items. Essentially, we're figuring out how many items will be held inside each group.

In the example widget above, our divisor (the number to be divided) is 12. 12 is a _remarkably_ clean number when it comes to division; it can be split neatly in lots of different ways.

Suppose we had the following equation instead:

```js
11 Ã· 4
```

This equation evaluates to `2.75`. Each group has 2 complete items, and then Â¾ths of another item.

This works if we're dividing up pizzas or cakesâ€¦ **but what if the items are indestructible?** What if we _can't_ break each item up into smaller fractions?

In that case, we'd be able to fit 2 items into each group, and we'd be left with 3 additional items:

<DivisionGroupsDemo
  includeRemainderArea={true}
  dividend={11}
  initialDivisor={4}
/>

**This is known as the _remainder_.** It's what the modulo operator produces.

In cases where the number can be equally divided into groups (eg. `12 Ã· 4`), there is nothing left over:

```js
12 % 4; // 0
```

In situations where the divisor (the number to be divided) _can't_ be split equally into groups, the modulo operator lets us know how much is left over:

```js
11 % 4; // 3
```

## A real-world use case

So, I'm not a mathematician, I'm a web developer. All of this math stuff is interesting, but let's talk about how the modulo operator can come in handy on the web.

Specifically, there's one sort of problem that I seem to run into a lot, where the modulo operator offers the perfect solution: _circular arrays._

For example, suppose we have an array of 3 colors. Each second, we want to switch to the next color in the list. When we reach the end of the list, we want to jump back to the first item:

DEMO

This is a surprisingly tricky problem. Suppose we have a variable called `timeElapsed` that starts at 0 and increments by 1 every second; we have to somehow map this ever-increasing value to an array with only 3 items.

Essentially, we need to write a function that produces the following results:

```js
getColor({ timeElapsed: 0 }); // Should return the 1st color
getColor({ timeElapsed: 1 }); // Should return the 2nd color
getColor({ timeElapsed: 2 }); // Should return the 3rd color
getColor({ timeElapsed: 3 }); // Should return the 1st color
getColor({ timeElapsed: 4 }); // Should return the 2nd color
getColor({ timeElapsed: 5 }); // Should return the 3rd color
getColor({ timeElapsed: 6 }); // Should return the 1st color
getColor({ timeElapsed: 7 }); // Should return the 2nd color
getColor({ timeElapsed: 8 }); // Should return the 3rd color
// ...And so on, forever
```

Let's look at how the modulo operator can help us solve this problem:

```js
function getColor({ timeElapsed }) {
  const COLORS = ['red', 'green', 'blue'];

  const colorIndex = timeElapsed % COLORS.length;

  return COLORS[colorIndex];
}
```

Miraculously, this does exactly what we need! This method will always return one of the 3 colors, as long as `timeElapsed` is an integer. And it'll cycle through the 3 colors as `timeElapsed` increases.

But _why_ does this work??

`COLORS.length` is equal to `3`, since there are 3 colors in our array. And so, as `timeElapsed` increments from 0 to 8, this function winds up performing the following sequence of calculations:

```js
const colorIndex = 0 % 3; // 0
const colorIndex = 1 % 3; // 1
const colorIndex = 2 % 3; // 2
const colorIndex = 3 % 3; // 0
const colorIndex = 4 % 3; // 1
const colorIndex = 5 % 3; // 2
const colorIndex = 6 % 3; // 0
const colorIndex = 7 % 3; // 1
const colorIndex = 8 % 3; // 2
```

This works because, conveniently, we're always left with a remainder
